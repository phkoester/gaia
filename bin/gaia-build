#!/usr/bin/env python3
#
# gaia-build
#

import argparse
import gaia
import gaia.list
import io
import json
import os

from gaia import log
from gaia.shell import error, run
from os import environ as env

# Classes ---------------------------------------------------------------------------------------------------

class ProjectType(gaia.enum.OrderedEnum):
  # Use lowercase names here so they can directly match command-line arguments
  none = 0
  cargo = 1
  make = 2

# Constants -------------------------------------------------------------------------------------------------

# List of all commands, in alphabetical order
COMMANDS = [
  "build",
  "check",
  "clean",
  "doc",
  "test",
  "update",
  "version",
]

# Commands by project type
COMMANDS_BY_PROJECT_TYPE = {
  ProjectType.cargo: ["build", "check", "clean", "doc", "test", "update", "version"],
  ProjectType.make: ["build", "check", "clean", "doc", "test", "version"],
  ProjectType.none: ["version"]
}

# Command dependencies
COMMANDS_DEPS = {
  "check": ["build"],
  "doc": ["build"],
  "test": ["build"],
}

# Commands in execution order
COMMANDS_ORDERED = [
  "clean",
  "update",
  "build",
  "check",
  "doc",
  "test",
  "version"
]

DESCRIPTION = "Process projects, execute commands or command lines."

EPILOG = """If no PROJECT is given, `all` is assumed by default.

If no COMMAND is given, `build` is assumed by default. Available COMMANDs:

build
        build all artifacts, including test artifacts
clean
        delete the entire build output
check
        perform static code analysis
doc
        generate documentation
test
        run tests
update
        check dependencies and look for newer versions
version
        print project version

Examples:

  gaia-build -pmake     # Run default command `build` for all Makefile projects
  gaia-build update     # Run command `update` for all projects
  gaia-build git status # Run command line `git status` for all projects"""

USAGE = """%(prog)s [OPTION]... [PROJECT]... [COMMAND]...
       %(prog)s [OPTION]... [PROJECT]... ARG..."""

# Functions -------------------------------------------------------------------------------------------------

def collectCommands(projectType: ProjectType, cmds: list[str]):
  # Add all commands available for this project type
  collected = []
  byProjectType = COMMANDS_BY_PROJECT_TYPE.get(projectType)
  if not byProjectType:
    return []
  log.debug(f"{cmds=}")
  for cmd in cmds:
    log.debug(f"{cmd=}")
    if cmd in byProjectType:
      # Add dependencies, if any
      deps = COMMANDS_DEPS.get(cmd)
      log.debug(f"{deps=}")
      if deps:
        collected.extend(deps)
      # Add command
      collected.append(cmd)
  log.debug(f"{collected=}")

  # Sort commands, eliminate duplicates
  result = []
  for cmd in COMMANDS_ORDERED:
    if cmd in collected:
      result.append(cmd)
  log.debug(f"{result=}")
  return result

def findRootDir() -> str:
  # Test current and parent directories
  dir = os.getcwd()
  while True:
    if testRootDir(dir):
      return dir
    if dir == "/":
      break
    dir = os.path.abspath(dir + "/..")

  # Test `~/project`
  dir = env["HOME"] + "/project"
  if testRootDir(dir):
    return dir
  
  raise RuntimeError("Cannot find root directory")

def getProjectDir(prj: str) -> str:
  return rootDir + "/" + prj

def getProjectJson(prj: str) -> str:
  dir = getProjectDir(prj)
  path = dir + "/project.json"
  with io.open(path, mode="r") as file:
    o = json.load(file)
    return o

def getProjectType(dir: str) -> ProjectType:
  if os.path.isfile(dir + "/Cargo.toml"):
    return ProjectType.cargo
  if os.path.isfile(dir + "/Makefile"):
    return ProjectType.make
  else:
    return ProjectType.none

# XXX Raus? WofÃ¼r brauchen wir versionCode?
def increaseVersionCode(prj: str) -> None:
  o = getProjectJson(prj)
  if "versionCode" in o:
    o["versionCode"] += 1
  else:
    o["versionCode"] = 1
  path = getProjectDir(prj) + "/project.json"
  with io.open(path, mode="w") as file:
    json.dump(o, file, ensure_ascii=False, indent=2, sort_keys=True)
    file.write("\n")

def parseCl() -> argparse.Namespace:
  parser = argparse.ArgumentParser(
    add_help=False,
    description=DESCRIPTION,
    epilog=EPILOG,
    formatter_class=argparse.RawDescriptionHelpFormatter,
    prog="gaia-build",
    usage=USAGE,
  )
  
  parser.add_argument("-a", "--all", action="store_true", dest="all",
      help="an \"all\" hint")
  parser.add_argument("-b", "--build-type", action="store", choices=["debug", "release"], dest="buildType", type=str,
      help="specify a build type")
  parser.add_argument("-h", "--help", action="help",
      help="show this help message and exit")
  parser.add_argument("-p", "--project-type", action="store", choices=ProjectType._member_names_, dest="projectType", type=str,
      help="filter projects by project type")
  parser.add_argument("-s", "--skip", action="store_true", dest="skip",
      help="skip processing dependencies")
  parser.add_argument("-v", "--verbose", action="store_true", dest="verbose",
      help="print verbose output")
  parser.add_argument("-w", "--warnings", action="store_true", dest="warnings",
      help="print all warnings")

  parser.add_argument("args", action="store", nargs="*", type=str)
  
  return parser.parse_args()

def parseCommandsOrCl() -> tuple[list[str], list[str]]:
  cmds, cl = [], []
  if not args.args:
    cmds = ["build"]
  elif args.args[0] not in COMMANDS:
    cl = args.args
    if cl[0] == "g": 
      cl[0] = "gaia-git"
  else:
    for cmd in args.args:
      if cmd in COMMANDS:
        if cmd not in cmds:
          cmds.append(cmd)
      else:
        error(f"Invalid command: `{cmd}`", 2, False)
  log.debug(f"{cmds=}, {cl=}")
  return cmds, cl

def parseProjects() -> list[str]:
  result = []
  # Consume `args` as long as the first element matches a project or "all"
  while True:
    prj = args.args and args.args[0] or None
    if not prj:
      break
    if prj == "all" or prj in projects:
      result.append(prj)
      del args.args[0]
    else:
      break
  if not result:
    result = ["all"]
  log.debug(f"{result=}, {args.args=}")

  # Resolve `all``
  tmp = result
  result = []
  for prj in tmp:
    if prj == "all":
      for p in sorted(projects.keys()):
        result.append(p)
    else:
      result.append(prj)
  log.debug(f"Resolved `all`, {result=}")

  # Resolve dependencies
  if not args.skip:
    tmp = result
    result = []
    for prj in tmp:
      result.extend(resolve(prj))
    log.debug(f"Resolved dependencies, {result=}")

  # Eliminate duplicates
  gaia.list.dedupIn(result)
  log.debug(f"Eliminated duplicates, {result=}")

  return result

def printSection(what: str, targets: list[str], cl: list[str] = None) -> None:
  s = 40 * "#" + "\n# \n# " + rootDir + "\n#\n# " + what
  if targets:
    s+= " > " + " ".join(targets)
    if cl:
      s += "\n#\n# $ " + " ".join(cl)
  else:
    s+= " $ " + " ".join(cl)
  s += "\n#\n" + 40 * "#"
  print(s)

def printVersion(prj: str) -> None:
  o = getProjectJson(prj)
  if "version" in o:
    version = o["version"]
    if "versionCode" in o:
      versionCode = o["versionCode"]
      print(f"{version} ({versionCode})")
    else:
      print(f"{version}")
  else:
    print("(No version information found.)")

def resolve(prj: str) -> list[str]:
  def resolve0(prj: str, out: list[str]):
    deps = projects[prj]
    for dep in deps:
      resolve0(dep, out) # Recursive call
    if prj not in out:
      result.append(prj)

  result = []
  resolve0(prj, result)
  return result

def runCargo(prj: str, cmds: list[str]) -> None:
  # Print section
  printSection(prj, cmds)

  # Run commands
  for cmd in cmds:
    cl = ["cargo"]
    clLen = len(cl)
    
    if cmd == "build":
      cl.append("build")
    elif cmd == "check":
      cl.append("clippy")
    elif cmd == "clean":
      cl.append("clean")
    elif cmd == "doc":
      cl.append("doc")
    elif cmd == "test":
      cl.append("test")
    elif cmd == "update":
      cl.append("update")
    elif cmd == "version":
      printVersion(prj)

    if len(cl) > clLen:
      if args.buildType == "release":
        cl.append("--release")
      log.debug(f"{cl=}")
      runCl(prj, cl)

def runCl(prj: str, cl: list[str]) -> None:
  dir = getProjectDir(prj)
  os.chdir(dir)
  run(cl, check=True)

def runMake(prj: str, cmds: list[str]) -> None:
  # Print section
  printSection(prj, cmds)

  # Run commands
  for cmd in cmds:
    cl = ["make"]
    gaiaMakeFlags = env.get("GAIA_MAKE_FLAGS")
    if gaiaMakeFlags:
      cl.extend(gaiaMakeFlags.split())
    clLen = len(cl)

    if cmd == "build":
      cl.append("build")
    elif cmd == "check":
      cl.append("check")
    elif cmd == "clean":
      cl.append("clean")
    elif cmd == "doc":
      cl.append("doc")
    elif cmd == "test":
      cl.append("test")
    elif cmd == "version":
      printVersion(prj)

    if len(cl) > clLen:
      if args.buildType:
        cl.append(f"GAIA_BUILD_TYPE={args.buildType}")
      log.debug(f"{cl=}")
      runCl(prj, cl)

def runNone(prj: str, cmds: list[str]) -> None:
  log.debug(f"{prj=}, {cmds=}")

  # Filter by accepted commands
  cmds = gaia.list.filter(cmds, ["version"])
  if len(cmds) == 0:
    return
  printSection(prj, cmds)

  # Run commands
  for cmd in cmds:
    if cmd == "version":
      printVersion(prj)

def testRootDir(dir: str) -> bool:
  if not os.path.isdir(dir):
    return False
  for file in os.listdir(dir):
    subdir = dir + "/" + file
    if os.path.isdir(subdir):
      if os.path.isfile(subdir + "/project.json"):
        return True
  return False

# Main ------------------------------------------------------------------------------------------------------

# Parse command line
args = parseCl()
log.debug(f"{args=}")

# Find root dir
rootDir = findRootDir()
log.debug(f"{rootDir=}")

# Collect projects and their dependencies from `project.json`
projects = {}
for prj in os.listdir(rootDir):
  subdir = rootDir + "/" + prj
  if os.path.isfile(subdir + "/project.json"):
    projects[prj] = []
    o = getProjectJson(prj)
    if "dependencies" in o:
      projects[prj] = o["dependencies"]
log.debug(f"{projects=}")

# Find out what to do (commands or command line)
prjs = parseProjects()
log.debug(f"{prjs=}")
cmds, cl = parseCommandsOrCl()
runCmds = len(cmds) > 0
log.debug(f"{cmds=}, {cl=}")

# Process projects
for prj in prjs:
  dir = getProjectDir(prj)
  projectType = getProjectType(dir)
  log.debug(f"{projectType=}")
  # If applicable, consider project-type filter
  if args.projectType and args.projectType != projectType.name:
    continue
  if runCmds:
    prjCmds = collectCommands(projectType, cmds)
    log.debug(f"{prj=}, {cmds=}")
    if len(prjCmds) > 0:
      # Execute commands, call appropriate runner
      if projectType == ProjectType.cargo:
        runCargo(prj, prjCmds)
      elif projectType == ProjectType.make:
        runMake(prj, prjCmds)
      else:
        runNone(prj, prjCmds)
  else:
    # Execute command line
    printSection(prj, None, cl)
    runCl(prj, cl)

# EOF
